#ifndef ACTOR_H
#define ACTOR_H

#include "Object.h"
#include "AIType.h"
#include "SpriteAnimation.h"
#include "Attribute.h"

#include <string>
#include <map>

namespace DavinciEngine{

	class TextureAtlas;
	class Attributes;

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary> The Actor object represents any pawn in the game (players and enemies). </summary>
	////////////////////////////////////////////////////////////////////////////////////////////////////
	class Actor : public Object
	{
	public:

		////////////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary> Destroys this object.</summary>
		////////////////////////////////////////////////////////////////////////////////////////////////////
		void Destroy();

		////////////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary> Creates an Actor object of actorType at xPos,yPos coordinates.
		/// 		  Loads Actor information from actorType.xml found in the data/actors
		/// 		  directory.</summary>
		///
		/// <param name="actorType"> Type of the actor.</param>
		/// <param name="xPos">		 (optional) the x coordinate position.</param>
		/// <param name="yPos">		 (optional) the y coordinate position.</param>
		///
		/// <returns> true if it succeeds, false if it fails.</returns>
		////////////////////////////////////////////////////////////////////////////////////////////////////
		static bool LoadActor(const char *actorType, float xPos = 0.0, float yPos = 0.0);

		////////////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary> Retrieves the attribute given by name from the Actor.
		/// 		  Usage: int hp = actor->GetAttribute<int>("hp");
		/// 		  std::string name = actor->GetAttribute<string>("name");</summary>
		///
		/// <param name="name"> The name.</param>
		///
		/// <returns> The attribute.</returns>
		////////////////////////////////////////////////////////////////////////////////////////////////////
		template <typename T> T GetAttribute(const std::string &name){
			return *m_pAttributes->GetAttribute<T*>(name);
		}

		////////////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary> Sets the Attribute given by name to the given value for the Actor.
		/// 		  Usage: actor->SetAttribute<int>("hp",100);
		/// 		  actor->SetAttribute<string>("name","Cloud");</summary>
		///
		/// <param name="name">  The name.</param>
		/// <param name="value"> The value.</param>
		///
		/// <returns> true if it succeeds, false if it fails.</returns>
		////////////////////////////////////////////////////////////////////////////////////////////////////
		template <typename T> bool SetAttribute(const std::string &name, const T &value){
			m_pAttributes->SetAttribute(name,value);
			return true;
		}

		////////////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary> Mouse left click.</summary>
		////////////////////////////////////////////////////////////////////////////////////////////////////
		void MouseLeftClick();

		////////////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary> Gets the type of Actor.</summary>
		///
		/// <returns> The type.</returns>
		////////////////////////////////////////////////////////////////////////////////////////////////////
		const std::string &GetType() override {return m_sActorType;}

		////////////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary> Gets the texture atlas of this Actor.</summary>
		///
		/// <returns> null if it fails, else the texture atlas.</returns>
		////////////////////////////////////////////////////////////////////////////////////////////////////
		TextureAtlas *GetTextureAtlas();

	protected:

		////////////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary> Destructor.</summary>
		////////////////////////////////////////////////////////////////////////////////////////////////////
		~Actor();

	private:

		////////////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary> Default constructor.</summary>
		////////////////////////////////////////////////////////////////////////////////////////////////////
		Actor();

		////////////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary> Copy constructor.</summary>
		///
		/// <param name="other"> The other.</param>
		////////////////////////////////////////////////////////////////////////////////////////////////////
		Actor(const Actor &other);

		////////////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary> Loads the XML data file for this Actor.</summary>
		///
		/// <param name="xmlDocument"> The XML document.</param>
		///
		/// <returns> true if it succeeds, false if it fails.</returns>
		////////////////////////////////////////////////////////////////////////////////////////////////////
		bool LoadXML(std::string &xmlDocument);

		////////////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary> The AI routine for this Actor.</summary>
		////////////////////////////////////////////////////////////////////////////////////////////////////
		void AIRoutine();

		////////////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary> Updates this object.</summary>
		////////////////////////////////////////////////////////////////////////////////////////////////////
		void Update() override;

		////////////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary> Check for collisions with this object.</summary>
		///
		/// <param name="prePosition"> [in,out] The pre position.</param>
		////////////////////////////////////////////////////////////////////////////////////////////////////
		void CheckCollisions(Vec2D &prePosition);

		////////////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary> Input checks to determine if any need handled by this Actor.</summary>
		////////////////////////////////////////////////////////////////////////////////////////////////////
		void InputChecks() override;

		////////////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary> Animates this object.</summary>
		////////////////////////////////////////////////////////////////////////////////////////////////////
		void Animate();

		////////////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary> Detect other Actor objects nearby.</summary>
		////////////////////////////////////////////////////////////////////////////////////////////////////
		void DetectOthers();

		////////////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary> Checks the attitude of other Actors.</summary>
		///
		/// <param name="otherActor"> The other actor.</param>
		///
		/// <returns> .</returns>
		////////////////////////////////////////////////////////////////////////////////////////////////////
		std::string CheckAttitude(const Actor *otherActor);

		////////////////////////////////////////////////////////////////////////////////////////////////////
		/// <summary> Copies this object.</summary>
		///
		/// <param name="newActor"> [in,out] If non-null, the new actor.</param>
		/// <param name="other">    Another instance to copy.</param>
		////////////////////////////////////////////////////////////////////////////////////////////////////
		static void Copy(Actor &newActor, const Actor &other);

		// Actor properties

		/// <summary> The pointer to the sprite associated with this Actor </summary>
		SpriteAnimation *m_pSprite;

		/// <summary> Pointer to the AI type assigned to this Actor </summary>
		AIType *m_pAIType;
		
		/// <summary> The Actor's type which is populated from the Actor's XML file. (The Root Node Value) </summary>
		std::string m_sActorType;

		/// <summary> The Actor's dynamic attributes from the Actor's XML file. </summary>
		Attributes *m_pAttributes;

		/// <summary> The pointer to the texture atlas associated with this Actor </summary>
		TextureAtlas *m_pTextureAtlas;

		/// <summary> A list of Actors that are in the vicinity of this Actor </summary>
		std::list<Object*> nearbyPawns;
	};
};
#endif